// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmtypes from "wasmlib/wasmtypes";

export class Bet {
	amount  : u64 = 0; 
	imageId : u32 = 0; 
	player  : wasmtypes.ScAddress = new wasmtypes.ScAddress();  // player placing the bet

	static fromBytes(buf: u8[]): Bet {
		const dec = new wasmtypes.WasmDecoder(buf);
		const data = new Bet();
		data.amount  = wasmtypes.uint64Decode(dec);
		data.imageId = wasmtypes.uint32Decode(dec);
		data.player  = wasmtypes.addressDecode(dec);
		dec.close();
		return data;
	}

	bytes(): u8[] {
		const enc = new wasmtypes.WasmEncoder();
		wasmtypes.uint64Encode(enc, this.amount);
		wasmtypes.uint32Encode(enc, this.imageId);
		wasmtypes.addressEncode(enc, this.player);
		return enc.buf();
	}
}

export class ImmutableBet extends wasmtypes.ScProxy {

	exists(): bool {
		return this.proxy.exists();
	}

	value(): Bet {
		return Bet.fromBytes(this.proxy.get());
	}
}

export class MutableBet extends wasmtypes.ScProxy {

	delete(): void {
		this.proxy.delete();
	}

	exists(): bool {
		return this.proxy.exists();
	}

	setValue(value: Bet): void {
		this.proxy.set(value.bytes());
	}

	value(): Bet {
		return Bet.fromBytes(this.proxy.get());
	}
}

export class PlayerBoost {
	nDoubleBoosts  : u64 = 0;  // Number of 2x boost used in the round
	nTags          : u64 = 0;  // Number of tags made by the player in the current round
	nTrippleBoosts : u64 = 0;  // Number of 3x boosts used in the round
	nValidTags     : u64 = 0;  // Number of validated tags made by the player in the current round. this is to calculate how much to pay them
	player         : wasmtypes.ScAgentID = wasmtypes.agentIDFromBytes([]);  // The player's AgentId

	static fromBytes(buf: u8[]): PlayerBoost {
		const dec = new wasmtypes.WasmDecoder(buf);
		const data = new PlayerBoost();
		data.nDoubleBoosts  = wasmtypes.uint64Decode(dec);
		data.nTags          = wasmtypes.uint64Decode(dec);
		data.nTrippleBoosts = wasmtypes.uint64Decode(dec);
		data.nValidTags     = wasmtypes.uint64Decode(dec);
		data.player         = wasmtypes.agentIDDecode(dec);
		dec.close();
		return data;
	}

	bytes(): u8[] {
		const enc = new wasmtypes.WasmEncoder();
		wasmtypes.uint64Encode(enc, this.nDoubleBoosts);
		wasmtypes.uint64Encode(enc, this.nTags);
		wasmtypes.uint64Encode(enc, this.nTrippleBoosts);
		wasmtypes.uint64Encode(enc, this.nValidTags);
		wasmtypes.agentIDEncode(enc, this.player);
		return enc.buf();
	}
}

export class ImmutablePlayerBoost extends wasmtypes.ScProxy {

	exists(): bool {
		return this.proxy.exists();
	}

	value(): PlayerBoost {
		return PlayerBoost.fromBytes(this.proxy.get());
	}
}

export class MutablePlayerBoost extends wasmtypes.ScProxy {

	delete(): void {
		this.proxy.delete();
	}

	exists(): bool {
		return this.proxy.exists();
	}

	setValue(value: PlayerBoost): void {
		this.proxy.set(value.bytes());
	}

	value(): PlayerBoost {
		return PlayerBoost.fromBytes(this.proxy.get());
	}
}

export class TaggedImage {
	boost   : string = "";  // if the tags will be boosted or not
	h       : string = "";  // heights of the Tags
	imageId : i32 = 0;  // the only signed integer (It is -1 by default)
	player  : wasmtypes.ScAddress = new wasmtypes.ScAddress();  // player that has tagged this image
	w       : string = "";  // widths of the Tags
	x       : string = "";  // x top-left positions of the Tags
	y       : string = "";  // y top-left positions of the Tags

	static fromBytes(buf: u8[]): TaggedImage {
		const dec = new wasmtypes.WasmDecoder(buf);
		const data = new TaggedImage();
		data.boost   = wasmtypes.stringDecode(dec);
		data.h       = wasmtypes.stringDecode(dec);
		data.imageId = wasmtypes.int32Decode(dec);
		data.player  = wasmtypes.addressDecode(dec);
		data.w       = wasmtypes.stringDecode(dec);
		data.x       = wasmtypes.stringDecode(dec);
		data.y       = wasmtypes.stringDecode(dec);
		dec.close();
		return data;
	}

	bytes(): u8[] {
		const enc = new wasmtypes.WasmEncoder();
		wasmtypes.stringEncode(enc, this.boost);
		wasmtypes.stringEncode(enc, this.h);
		wasmtypes.int32Encode(enc, this.imageId);
		wasmtypes.addressEncode(enc, this.player);
		wasmtypes.stringEncode(enc, this.w);
		wasmtypes.stringEncode(enc, this.x);
		wasmtypes.stringEncode(enc, this.y);
		return enc.buf();
	}
}

export class ImmutableTaggedImage extends wasmtypes.ScProxy {

	exists(): bool {
		return this.proxy.exists();
	}

	value(): TaggedImage {
		return TaggedImage.fromBytes(this.proxy.get());
	}
}

export class MutableTaggedImage extends wasmtypes.ScProxy {

	delete(): void {
		this.proxy.delete();
	}

	exists(): bool {
		return this.proxy.exists();
	}

	setValue(value: TaggedImage): void {
		this.proxy.set(value.bytes());
	}

	value(): TaggedImage {
		return TaggedImage.fromBytes(this.proxy.get());
	}
}

export class ValidTag {
	playTagId   : u32 = 0;  // Identifier to distinguish different tags in the same play
	player      : wasmtypes.ScAddress = new wasmtypes.ScAddress();  // player placing the bet
	taggedImage : u32 = 0; 

	static fromBytes(buf: u8[]): ValidTag {
		const dec = new wasmtypes.WasmDecoder(buf);
		const data = new ValidTag();
		data.playTagId   = wasmtypes.uint32Decode(dec);
		data.player      = wasmtypes.addressDecode(dec);
		data.taggedImage = wasmtypes.uint32Decode(dec);
		dec.close();
		return data;
	}

	bytes(): u8[] {
		const enc = new wasmtypes.WasmEncoder();
		wasmtypes.uint32Encode(enc, this.playTagId);
		wasmtypes.addressEncode(enc, this.player);
		wasmtypes.uint32Encode(enc, this.taggedImage);
		return enc.buf();
	}
}

export class ImmutableValidTag extends wasmtypes.ScProxy {

	exists(): bool {
		return this.proxy.exists();
	}

	value(): ValidTag {
		return ValidTag.fromBytes(this.proxy.get());
	}
}

export class MutableValidTag extends wasmtypes.ScProxy {

	delete(): void {
		this.proxy.delete();
	}

	exists(): bool {
		return this.proxy.exists();
	}

	setValue(value: ValidTag): void {
		this.proxy.set(value.bytes());
	}

	value(): ValidTag {
		return ValidTag.fromBytes(this.proxy.get());
	}
}
