// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

#![allow(dead_code)]
#![allow(unused_imports)]

use wasmlib::*;

#[derive(Clone)]
pub struct Bet {
    pub amount   : u64, 
    pub image_id : u32, 
    pub player   : ScAddress,  // player placing the bet
}

impl Bet {
    pub fn from_bytes(bytes: &[u8]) -> Bet {
        let mut dec = WasmDecoder::new(bytes);
        Bet {
            amount   : uint64_decode(&mut dec),
            image_id : uint32_decode(&mut dec),
            player   : address_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
		uint64_encode(&mut enc, self.amount);
		uint32_encode(&mut enc, self.image_id);
		address_encode(&mut enc, &self.player);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableBet {
    pub(crate) proxy: Proxy,
}

impl ImmutableBet {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> Bet {
        Bet::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableBet {
    pub(crate) proxy: Proxy,
}

impl MutableBet {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &Bet) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> Bet {
        Bet::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct PlayerInfo {
    pub n_double_boosts  : u64,  // Number of 2x boost used in the round
    pub n_tags           : u64,  // Number of tags made by the player in the current round
    pub n_tripple_boosts : u64,  // Number of 3x boosts used in the round
    pub n_valid_tags     : u64,  // Number of validated tags made by the player in the current round. this is to calculate how much to pay them
    pub player           : ScAgentID,  // The player's AgentId
}

impl PlayerInfo {
    pub fn from_bytes(bytes: &[u8]) -> PlayerInfo {
        let mut dec = WasmDecoder::new(bytes);
        PlayerInfo {
            n_double_boosts  : uint64_decode(&mut dec),
            n_tags           : uint64_decode(&mut dec),
            n_tripple_boosts : uint64_decode(&mut dec),
            n_valid_tags     : uint64_decode(&mut dec),
            player           : agent_id_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
		uint64_encode(&mut enc, self.n_double_boosts);
		uint64_encode(&mut enc, self.n_tags);
		uint64_encode(&mut enc, self.n_tripple_boosts);
		uint64_encode(&mut enc, self.n_valid_tags);
		agent_id_encode(&mut enc, &self.player);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutablePlayerInfo {
    pub(crate) proxy: Proxy,
}

impl ImmutablePlayerInfo {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> PlayerInfo {
        PlayerInfo::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutablePlayerInfo {
    pub(crate) proxy: Proxy,
}

impl MutablePlayerInfo {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &PlayerInfo) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> PlayerInfo {
        PlayerInfo::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct TgdImg {
    pub boost    : String,  // if the tags will be boosted or not
    pub h        : String,  // heights of the Tags
    pub image_id : i32,  // the only signed integer (It is -1 by default)
    pub player   : ScAddress,  // player that has tagged this image
    pub w        : String,  // widths of the Tags
    pub x        : String,  // x top-left positions of the Tags
    pub y        : String,  // y top-left positions of the Tags
}

impl TgdImg {
    pub fn from_bytes(bytes: &[u8]) -> TgdImg {
        let mut dec = WasmDecoder::new(bytes);
        TgdImg {
            boost    : string_decode(&mut dec),
            h        : string_decode(&mut dec),
            image_id : int32_decode(&mut dec),
            player   : address_decode(&mut dec),
            w        : string_decode(&mut dec),
            x        : string_decode(&mut dec),
            y        : string_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
		string_encode(&mut enc, &self.boost);
		string_encode(&mut enc, &self.h);
		int32_encode(&mut enc, self.image_id);
		address_encode(&mut enc, &self.player);
		string_encode(&mut enc, &self.w);
		string_encode(&mut enc, &self.x);
		string_encode(&mut enc, &self.y);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableTgdImg {
    pub(crate) proxy: Proxy,
}

impl ImmutableTgdImg {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> TgdImg {
        TgdImg::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableTgdImg {
    pub(crate) proxy: Proxy,
}

impl MutableTgdImg {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &TgdImg) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> TgdImg {
        TgdImg::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct ValidTag {
    pub play_tag_id : u32,  // Identifier to distinguish different tags in the same play
    pub player      : ScAddress,  // player placing the bet
    pub tgd_img     : u32,  // Tagged Image
}

impl ValidTag {
    pub fn from_bytes(bytes: &[u8]) -> ValidTag {
        let mut dec = WasmDecoder::new(bytes);
        ValidTag {
            play_tag_id : uint32_decode(&mut dec),
            player      : address_decode(&mut dec),
            tgd_img     : uint32_decode(&mut dec),
        }
    }

    pub fn to_bytes(&self) -> Vec<u8> {
        let mut enc = WasmEncoder::new();
		uint32_encode(&mut enc, self.play_tag_id);
		address_encode(&mut enc, &self.player);
		uint32_encode(&mut enc, self.tgd_img);
        enc.buf()
    }
}

#[derive(Clone)]
pub struct ImmutableValidTag {
    pub(crate) proxy: Proxy,
}

impl ImmutableValidTag {
    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn value(&self) -> ValidTag {
        ValidTag::from_bytes(&self.proxy.get())
    }
}

#[derive(Clone)]
pub struct MutableValidTag {
    pub(crate) proxy: Proxy,
}

impl MutableValidTag {
    pub fn delete(&self) {
        self.proxy.delete();
    }

    pub fn exists(&self) -> bool {
        self.proxy.exists()
    }

    pub fn set_value(&self, value: &ValidTag) {
        self.proxy.set(&value.to_bytes());
    }

    pub fn value(&self) -> ValidTag {
        ValidTag::from_bytes(&self.proxy.get())
    }
}
