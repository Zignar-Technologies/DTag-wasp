// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

package zentangle

import "github.com/iotaledger/wasp/packages/wasmvm/wasmlib/go/wasmlib/wasmtypes"

type Bet struct {
	Amount  uint64 
	ImageId uint32 
	Player  wasmtypes.ScAddress  // player placing the bet
}

func NewBetFromBytes(buf []byte) *Bet {
	dec := wasmtypes.NewWasmDecoder(buf)
	data := &Bet{}
	data.Amount  = wasmtypes.Uint64Decode(dec)
	data.ImageId = wasmtypes.Uint32Decode(dec)
	data.Player  = wasmtypes.AddressDecode(dec)
	dec.Close()
	return data
}

func (o *Bet) Bytes() []byte {
	enc := wasmtypes.NewWasmEncoder()
		wasmtypes.Uint64Encode(enc, o.Amount)
		wasmtypes.Uint32Encode(enc, o.ImageId)
		wasmtypes.AddressEncode(enc, o.Player)
	return enc.Buf()
}

type ImmutableBet struct {
	proxy wasmtypes.Proxy
}

func (o ImmutableBet) Exists() bool {
	return o.proxy.Exists()
}

func (o ImmutableBet) Value() *Bet {
	return NewBetFromBytes(o.proxy.Get())
}

type MutableBet struct {
	proxy wasmtypes.Proxy
}

func (o MutableBet) Delete() {
	o.proxy.Delete()
}

func (o MutableBet) Exists() bool {
	return o.proxy.Exists()
}

func (o MutableBet) SetValue(value *Bet) {
	o.proxy.Set(value.Bytes())
}

func (o MutableBet) Value() *Bet {
	return NewBetFromBytes(o.proxy.Get())
}

type PlayerInfo struct {
	NDoubleBoosts  uint64  // Number of 2x boost used in the round
	NTags          uint64  // Number of tags made by the player in the current round
	NTrippleBoosts uint64  // Number of 3x boosts used in the round
	NValidTags     uint64  // Number of validated tags made by the player in the current round. this is to calculate how much to pay them
	Player         wasmtypes.ScAgentID  // The player's AgentId
}

func NewPlayerInfoFromBytes(buf []byte) *PlayerInfo {
	dec := wasmtypes.NewWasmDecoder(buf)
	data := &PlayerInfo{}
	data.NDoubleBoosts  = wasmtypes.Uint64Decode(dec)
	data.NTags          = wasmtypes.Uint64Decode(dec)
	data.NTrippleBoosts = wasmtypes.Uint64Decode(dec)
	data.NValidTags     = wasmtypes.Uint64Decode(dec)
	data.Player         = wasmtypes.AgentIDDecode(dec)
	dec.Close()
	return data
}

func (o *PlayerInfo) Bytes() []byte {
	enc := wasmtypes.NewWasmEncoder()
		wasmtypes.Uint64Encode(enc, o.NDoubleBoosts)
		wasmtypes.Uint64Encode(enc, o.NTags)
		wasmtypes.Uint64Encode(enc, o.NTrippleBoosts)
		wasmtypes.Uint64Encode(enc, o.NValidTags)
		wasmtypes.AgentIDEncode(enc, o.Player)
	return enc.Buf()
}

type ImmutablePlayerInfo struct {
	proxy wasmtypes.Proxy
}

func (o ImmutablePlayerInfo) Exists() bool {
	return o.proxy.Exists()
}

func (o ImmutablePlayerInfo) Value() *PlayerInfo {
	return NewPlayerInfoFromBytes(o.proxy.Get())
}

type MutablePlayerInfo struct {
	proxy wasmtypes.Proxy
}

func (o MutablePlayerInfo) Delete() {
	o.proxy.Delete()
}

func (o MutablePlayerInfo) Exists() bool {
	return o.proxy.Exists()
}

func (o MutablePlayerInfo) SetValue(value *PlayerInfo) {
	o.proxy.Set(value.Bytes())
}

func (o MutablePlayerInfo) Value() *PlayerInfo {
	return NewPlayerInfoFromBytes(o.proxy.Get())
}

type TgdImg struct {
	Boost   string  // if the tags will be boosted or not
	H       string  // heights of the Tags
	ImageId int32  // the only signed integer (It is -1 by default)
	Player  wasmtypes.ScAddress  // player that has tagged this image
	W       string  // widths of the Tags
	X       string  // x top-left positions of the Tags
	Y       string  // y top-left positions of the Tags
}

func NewTgdImgFromBytes(buf []byte) *TgdImg {
	dec := wasmtypes.NewWasmDecoder(buf)
	data := &TgdImg{}
	data.Boost   = wasmtypes.StringDecode(dec)
	data.H       = wasmtypes.StringDecode(dec)
	data.ImageId = wasmtypes.Int32Decode(dec)
	data.Player  = wasmtypes.AddressDecode(dec)
	data.W       = wasmtypes.StringDecode(dec)
	data.X       = wasmtypes.StringDecode(dec)
	data.Y       = wasmtypes.StringDecode(dec)
	dec.Close()
	return data
}

func (o *TgdImg) Bytes() []byte {
	enc := wasmtypes.NewWasmEncoder()
		wasmtypes.StringEncode(enc, o.Boost)
		wasmtypes.StringEncode(enc, o.H)
		wasmtypes.Int32Encode(enc, o.ImageId)
		wasmtypes.AddressEncode(enc, o.Player)
		wasmtypes.StringEncode(enc, o.W)
		wasmtypes.StringEncode(enc, o.X)
		wasmtypes.StringEncode(enc, o.Y)
	return enc.Buf()
}

type ImmutableTgdImg struct {
	proxy wasmtypes.Proxy
}

func (o ImmutableTgdImg) Exists() bool {
	return o.proxy.Exists()
}

func (o ImmutableTgdImg) Value() *TgdImg {
	return NewTgdImgFromBytes(o.proxy.Get())
}

type MutableTgdImg struct {
	proxy wasmtypes.Proxy
}

func (o MutableTgdImg) Delete() {
	o.proxy.Delete()
}

func (o MutableTgdImg) Exists() bool {
	return o.proxy.Exists()
}

func (o MutableTgdImg) SetValue(value *TgdImg) {
	o.proxy.Set(value.Bytes())
}

func (o MutableTgdImg) Value() *TgdImg {
	return NewTgdImgFromBytes(o.proxy.Get())
}

type ValidTag struct {
	PlayTagId uint32  // Identifier to distinguish different tags in the same play
	Player    wasmtypes.ScAddress  // player placing the bet
	TgdImg    uint32  // Tagged Image
}

func NewValidTagFromBytes(buf []byte) *ValidTag {
	dec := wasmtypes.NewWasmDecoder(buf)
	data := &ValidTag{}
	data.PlayTagId = wasmtypes.Uint32Decode(dec)
	data.Player    = wasmtypes.AddressDecode(dec)
	data.TgdImg    = wasmtypes.Uint32Decode(dec)
	dec.Close()
	return data
}

func (o *ValidTag) Bytes() []byte {
	enc := wasmtypes.NewWasmEncoder()
		wasmtypes.Uint32Encode(enc, o.PlayTagId)
		wasmtypes.AddressEncode(enc, o.Player)
		wasmtypes.Uint32Encode(enc, o.TgdImg)
	return enc.Buf()
}

type ImmutableValidTag struct {
	proxy wasmtypes.Proxy
}

func (o ImmutableValidTag) Exists() bool {
	return o.proxy.Exists()
}

func (o ImmutableValidTag) Value() *ValidTag {
	return NewValidTagFromBytes(o.proxy.Get())
}

type MutableValidTag struct {
	proxy wasmtypes.Proxy
}

func (o MutableValidTag) Delete() {
	o.proxy.Delete()
}

func (o MutableValidTag) Exists() bool {
	return o.proxy.Exists()
}

func (o MutableValidTag) SetValue(value *ValidTag) {
	o.proxy.Set(value.Bytes())
}

func (o MutableValidTag) Value() *ValidTag {
	return NewValidTagFromBytes(o.proxy.Get())
}
